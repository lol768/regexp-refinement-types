@book{benjaminpierce2002,
    author = {Benjamin Pierce},
    title = {Types and Programming Languages},
    publisher = {The MIT Press},
    year = {2002}
}
@techreport{msftttmr2012,
    author = {Livshits, Ben},
    title = {Dynamic Taint Tracking in Managed Runtimes},
    year = {2012},
    month = {November},
    abstract = {
    This paper provides a taxonomy of runtime taint tracking approaches for managed code, such as code written in Java, C#, PHP, Perl, or Ruby. It covers main applications of data tainting such as preventing web application vulnerabilities including cross-site scripting and SQL injection attacks, along with disallowing privacy-sensitive data leaks. In addition to giving an overview of related literature from the last decade, this paper provides guidance and describes the trade-offs of different instrumentation approaches. Lastly, we provide a list of open problems whose solutions would aid practical adaption of runtime tainting on a wider scale.
    },
    publisher = {Microsoft Research},
    url = {https://www.microsoft.com/en-us/research/publication/dynamic-taint-tracking-in-managed-runtimes/},
}

% Ref'd from Ranjit Jhala's Language-Integrated Verification talk
@article{sadowski2018lessons,
    title     = "Lessons from Building Static Analysis Tools at Google",
    author    = "SADOWSKI, CAITLIN and AFTANDILIAN, EDWARD and EAGLE, ALEX and MILLER-CUSHON, LIAM and JASPAN, CIERA",
    journal   = "Communigcations of the ACM",
    volume    = "61",
    number    = "4",
    year      = "2018"
}

@phdthesis{nelson1980,
    author    = "Nelson, Charles Gregory",
    title     = "Techniques for Program Verification",
    year      = "1980",
    note      = "AAI8011683",
    publisher = "Stanford University",
    address   = "Stanford, CA, USA",
}

@inproceedings{Abadi:1999:CCD:292540.292555,
    author = {Abadi, Mart\'{\i}n and Banerjee, Anindya and Heintze, Nevin and Riecke, Jon G.},
    title = {A Core Calculus of Dependency},
    booktitle = {Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    series = {POPL '99},
    year = {1999},
    isbn = {1-58113-095-3},
    location = {San Antonio, Texas, USA},
    pages = {147--160},
    numpages = {14},
    url = {http://doi.acm.org/10.1145/292540.292555},
    doi = {10.1145/292540.292555},
    acmid = {292555},
    publisher = {ACM},
    address = {New York, NY, USA},
}

@inproceedings{heintze1998slam,
    title={The SLam calculus: programming with secrecy and integrity},
    author={Heintze, Nevin and Riecke, Jon G},
    booktitle={Proceedings of the 25th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
    pages={365--377},
    year={1998},
    organization={ACM}
}

@MISC{Sumii02logicalrelations,
    author = {Eijiro Sumii and Benjamin C. Pierce},
    title = {Logical Relations for Encryption},
    year = {2002}
}

@article{miltersen2005converting,
	title={On converting CNF to DNF},
	author={Miltersen, Peter Bro and Radhakrishnan, Jaikumar and Wegener, Ingo},
	journal={Theoretical computer science},
	volume={347},
	number={1-2},
	pages={325--335},
	year={2005},
	publisher={Elsevier}
}

@inproceedings{Cook:1971:CTP:800157.805047,
	author = {Cook, Stephen A.},
	title = {The Complexity of Theorem-proving Procedures},
	booktitle = {Proceedings of the Third Annual ACM Symposium on Theory of Computing},
	series = {STOC '71},
	year = {1971},
	location = {Shaker Heights, Ohio, USA},
	pages = {151--158},
	numpages = {8},
	url = {http://doi.acm.org/10.1145/800157.805047},
	doi = {10.1145/800157.805047},
	acmid = {805047},
	publisher = {ACM},
	address = {New York, NY, USA},
} 
@book{sipser2012introduction,
	title={Introduction to the Theory of Computation},
	author={Sipser, Michael},
	year={2012},
	publisher={Cengage Learning}
}
@article{rabin1959finite,
	title={Finite automata and their decision problems},
	author={Rabin, Michael O and Scott, Dana},
	journal={IBM journal of research and development},
	volume={3},
	number={2},
	pages={114--125},
	year={1959},
	publisher={IBM}
}

@book{Knuth:2015:ACP:2898950,
	author = {Knuth, Donald E.},
	title = {The Art of Computer Programming, Volume 4, Fascicle 6: Satisfiability},
	year = {2015},
	isbn = {0134397606, 9780134397603},
	edition = {1st},
	publisher = {Addison-Wesley Professional},
} 
@TechReport{dafny,
	author = {Moskal, Michal},
	title = {Co-Induction Simply: Automatic Co-Inductive Proofs in a Program Verifier},
	year = {2013},
	month = {July},
	abstract = {
	
	Program verification relies heavily on induction, which has received decades of attention in mechanical verification tools. When program correctness is best described by infinite structures, program verification is usefully aided also by co-induction, which has not benefited from the same degree of tool support. Co-induction is complicated to work with in interactive proof assistants and has had no previous support in dedicated program verifiers. This paper shows that an SMT-based program verifier can support reasoning about co-inductionâ€”handling infinite data structures, lazy function calls, and user-defined properties defined as greatest fix-points, as well as letting users write co-inductive proofs. Moreover, the support can be packaged to provide a simple user experience. The paper describes the features for co-induction in the language and verifier Dafny, defines their translation into input for a first-order SMT solver, and reports on some encouraging initial experience.
	
	
	},
	publisher = {Microsoft Research},
	url = {https://www.microsoft.com/en-us/research/publication/co-induction-simply-automatic-co-inductive-proofs-in-a-program-verifier/},
}
@InProceedings{dafny2,
	author="Leino, K. Rustan M.",
	editor="Clarke, Edmund M.
	and Voronkov, Andrei",
	title="Dafny: An Automatic Program Verifier for Functional Correctness",
	booktitle="Logic for Programming, Artificial Intelligence, and Reasoning",
	year="2010",
	publisher="Springer Berlin Heidelberg",
	address="Berlin, Heidelberg",
	pages="348--370",
	abstract="Traditionally, the full verification of a program's functional correctness has been obtained with pen and paper or with interactive proof assistants, whereas only reduced verification tasks, such as extended static checking, have enjoyed the automation offered by satisfiability-modulo-theories (SMT) solvers. More recently, powerful SMT solvers and well-designed program verifiers are starting to break that tradition, thus reducing the effort involved in doing full verification.",
	isbn="978-3-642-17511-4"
}

@article{Davis:1960:CPQ:321033.321034,
	author = {Davis, Martin and Putnam, Hilary},
	title = {A Computing Procedure for Quantification Theory},
	journal = {J. ACM},
	issue_date = {July 1960},
	volume = {7},
	number = {3},
	month = jul,
	year = {1960},
	issn = {0004-5411},
	pages = {201--215},
	numpages = {15},
	url = {http://doi.acm.org/10.1145/321033.321034},
	doi = {10.1145/321033.321034},
	acmid = {321034},
	publisher = {ACM},
	address = {New York, NY, USA},
}
@inproceedings{de2008z3,
	title={Z3: An efficient SMT solver},
	author={De Moura, Leonardo and Bj{\o}rner, Nikolaj},
	booktitle={International conference on Tools and Algorithms for the Construction and Analysis of Systems},
	pages={337--340},
	year={2008},
	organization={Springer}
}

% + https://www.joachim-breitner.de/blog/734-Finding_bugs_in_Haskell_code_by_proving_it
